/**
 * ============================================================================
 * CONFIG LOADER - Dynamic Configuration from config.json
 * ============================================================================
 *
 * PURPOSE:
 * Loads tier configuration from config.json at runtime instead of hardcoding.
 * This allows the GitHub Action to inject custom tiers + Stripe price IDs
 * without modifying the Worker code.
 *
 * HOW IT WORKS:
 * 1. GitHub Action generates config.json with tiers from KV
 * 2. GitHub Action creates Stripe products (gets price IDs)
 * 3. GitHub Action writes config.json to api/src/config/config.json
 * 4. This file loads config.json and transforms it to Worker format
 * 5. All API endpoints use these tiers instead of hardcoded TIER_CONFIG
 *
 * CONFIG STRUCTURE (from GitHub Action):
 * {
 *   tiers: [
 *     {
 *       id: "free",
 *       name: "Free",
 *       price: 0,
 *       limit: 7,
 *       features: ["Basic access"],
 *       popular: false,
 *       stripePriceId: null
 *     },
 *     {
 *       id: "pro",
 *       name: "Pro",
 *       price: 29,
 *       limit: 100,
 *       features: ["Everything", "Priority support"],
 *       popular: true,
 *       stripePriceId: "price_1234abcd"
 *     }
 *   ]
 * }
 *
 * ============================================================================
 */

import { TierConfig, Env } from '../types';

interface Branding {
  appName: string;
  logoUrl: string;
  primaryColor: string;
  valueProp: string;
  description: string;
  heroImageUrl: string;
}

interface Product {
  name: string;
}

/**
 * Tier configuration from config.json (generated by GitHub Action)
 */
interface ConfigTier {
  id: string;
  name: string;
  price: number;
  limit: number | 'unlimited';
  features?: string[] | string;
  popular?: boolean;
  stripePriceId?: string | null;
  priceId?: string | null;
  productId?: string | null;
}

interface Config {
  tiers: ConfigTier[];
  branding?: Branding;
  product?: Product;
  apiUrl?: string;
  clerkPublishableKey?: string;
}

/**
 * MULTI-TENANT CONFIG LOADER
 *
 * SINGLE MODE:
 * - Reads from user's KV namespace based on Clerk userId
 * - No platformUserId support (simpler, more secure)
 *
 * @param env - Worker environment (for KV access)
 * @param userId - User ID from Clerk JWT
 * @returns {Promise<Config>} Configuration object
 */
interface TierConfigData {
  productName?: string;
  tiers: ConfigTier[];
}

interface ConfigModule {
  config: Config;
}

async function loadTiersFromDb(env: Env, platformId?: string): Promise<Config | null> {
  if (!platformId || !env.DB) return null;

  const rows = await env.DB.prepare(
    'SELECT name, displayName, price, "limit", priceId, productId, features, popular FROM tiers WHERE platformId = ?'
  )
    .bind(platformId)
    .all<{
      name: string;
      displayName: string | null;
      price: number;
      limit: number | null;
      priceId: string | null;
      productId: string | null;
      features: string | null;
      popular: number | null;
    }>();

  // Normalize features string to array; supports JSON string or comma-separated list
  const parseFeatures = (raw: string | null): string[] => {
    if (!raw) return [];
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) return parsed;
      if (typeof parsed === 'string') return [parsed];
    } catch {
      // Fallback: split comma-separated string
      return raw.split(',').map((f) => f.trim()).filter(Boolean);
    }
    return [];
  };

  if (!rows.results || rows.results.length === 0) return null;

  const tiers: ConfigTier[] = rows.results.map((row) => ({
    id: row.name,
    name: row.displayName || row.name,
    price: row.price,
    limit: row.limit === null ? 'unlimited' : row.limit,
    features: parseFeatures(row.features),
    popular: !!row.popular,
    stripePriceId: row.priceId,
    priceId: row.priceId,
    productId: row.productId,
  }));

  return { tiers };
}

async function loadConfig(env: Env, platformId?: string): Promise<Config> {
  try {
    // Prefer D1 tiers if available
    const dbConfig = await loadTiersFromDb(env, platformId);
    if (dbConfig) {
      return dbConfig;
    }

    // MULTI-TENANT MODE: Read tier config from TOKENS_KV
    // oauth-api stores it at platform:{platformId}:tierConfig after product creation
    if (platformId && env?.TOKENS_KV) {
      console.log(`[ConfigLoader] MULTI-TENANT: Loading config for platform ${platformId}`);

      // Read tier config from TOKENS_KV (oauth-api stores it at platform:{platformId}:tierConfig)
      const tierConfigJson = await env.TOKENS_KV.get(`platform:${platformId}:tierConfig`);
      if (!tierConfigJson) {
        throw new Error(`No tier config found for platform: ${platformId} in TOKENS_KV`);
      }

      const tierData: TierConfigData = JSON.parse(tierConfigJson);
      console.log('[ConfigLoader] Loaded tiers from TOKENS_KV:', tierData);
      return { tiers: tierData.tiers || [] };
    }

    console.warn(
      `[ConfigLoader] No tier config found for platform: ${platformId} in TOKENS_KV. Falling back to static config.`
    );

    // STATIC MODE: Read from bundled config.ts (for customer production deploys)
    console.log('[ConfigLoader] STATIC: Loading from config.ts');
    const configModule: ConfigModule = await import('./config');
    return configModule.config;
  } catch (error) {
    console.error('[ConfigLoader] Config load failed:', error);
    throw new Error(`Config load failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

/**
 * Transform config tiers to TIER_CONFIG format
 *
 * Converts config.json format to the TierConfig format used by the Worker.
 *
 * @param {ConfigTier[]} tiers - Tiers from config.json
 * @returns {Record<string, TierConfig>} Tier configuration map
 */
function transformTiers(tiers: ConfigTier[]): Record<string, TierConfig> {
  const tierConfig: Record<string, TierConfig> = {};

  for (const tier of tiers) {
    // Use tier.name as key (workflow stores tiers with 'name' field, not 'id')
    const key = tier.id || tier.name;
    tierConfig[key] = {
      name: tier.name,
      price: tier.price,
      limit: tier.limit === 'unlimited' ? Infinity : tier.limit,
    };
  }

  return tierConfig;
}

/**
 * Get tier configuration (multi-tenant)
 */
export async function getTierConfig(env: Env, platformId?: string): Promise<Record<string, TierConfig>> {
  const config = await loadConfig(env, platformId);
  return transformTiers(config.tiers);
}

/**
 * Get Stripe Price ID map (multi-tenant)
 */
export async function getPriceIdMap(env: Env, platformId?: string): Promise<Record<string, string>> {
  const config = await loadConfig(env, platformId);
  const priceIdMap: Record<string, string> = {};

  for (const tier of config.tiers) {
    const priceId = tier.stripePriceId || tier.priceId; // Support both field names
    const key = tier.name || tier.id;
    if (!priceId || !key) continue;

    // Preserve original key and add a lowercase variant so "pro"/"Pro" both work.
    priceIdMap[key] = priceId;
    priceIdMap[key.toLowerCase()] = priceId;
  }

  return priceIdMap;
}

/**
 * Get all tiers (multi-tenant)
 */
export async function getAllTiers(env: Env, platformId?: string): Promise<ConfigTier[]> {
  const config = await loadConfig(env, platformId);
  return config.tiers;
}

/**
 * USAGE EXAMPLES:
 *
 * // Replace old TIER_CONFIG usage:
 * import { getTierConfig } from './config/configLoader';
 * const TIER_CONFIG = await getTierConfig();
 * const userLimit = TIER_CONFIG[plan].limit;
 *
 * // Replace old PRICE_ID_MAP usage:
 * import { getPriceIdMap } from './config/configLoader';
 * const priceIdMap = await getPriceIdMap(env);
 * const stripePriceId = priceIdMap[tier];
 *
 * // Get all tiers for /api/tiers endpoint:
 * import { getAllTiers } from './config/configLoader';
 * const tiers = await getAllTiers();
 * return Response.json({ tiers });
 */
